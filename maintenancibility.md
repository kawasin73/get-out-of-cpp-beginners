## メンテナンス性

本書の読者の方々には、是非メンテナンス性を重視してコードを書いてもらいたいと思っています。
メンテナンス性は必ずしも C++ 特有の話ではなく、プログラミング、ソフトウェア設計実装において重要な話題ですが、
とりわけ C++ は一歩間違えるとコードや実行結果が大変なことになる気難しい側面がありますので、
ここではメンテナンス性についてもう少し具体的に考えてみたいと思います。
メンテナンス性が良いとは、コードの読み手がより少ない労力や時間で必要な情報を得られることと、より少ない労力や時間で必要とするコード修正やテストを行えることだと思います。
つまり、読みやすく、修正しやすいということです。
読みやすさ、修正しやすさを定量的に表すのは難しそうですが、
長い期間使われるコードであればあるほど、コードやドキュメントのメンテナンス性の良さはソフトウェアのコスト対効果の向上に大きな貢献をします。
コードを書くとき、レビューするときは、以下の複数の観点から、よりメンテナンス性の良いコードにするにはどうしたら良いかということを考えてください。


### 名前

変数、関数、クラスの名前はメンテナンス性にとって重要です。
「名は体を表す」の諺通り、中身を読まなくてもその挙動を推測するのに役立ちます。
無意味な名前や、とんちんかんな名前がついていると、読み手は中身を読んでその意味を理解する必要があったり、
誤解して正しい理解を妨げてしまったりします。
良い名前をつけましょう。
品詞の使い分けについては様々な場所で言及されていますので、ここでは議論しません。
ラムダ関数が無名で許されるのは、ひと目見れば内容が分かるくらい単純なもので、わざわざ名前をつけなくても内容の把握が簡単だからなのです。
当然、ひと目見て何をやっているのか分からないようなラムダ関数を作るべきではありません。


### 型

C++ は静的型付け言語に分類されます。
ほとんどの変数やオブジェクトの型が静的に、すなわちコンパイル時に解決されます。
そのルールを逸脱するコードはコンパイルエラーとなります。
Python などの動的型付け言語に比べれば、プログラムを動かす前に型による制約を守っていることが求められるので、わずらわしいと思う人がいるかも知れません。
しかし、メンテナンスの観点からは、静的型付け言語はとても重要な性質を持っています。
それは、コンパイルが通った時点で型エラーは排除されているいうことです。
すなわち、実行しているときに、ある変数と実際のオブジェクトの型が異なって、やろうとしている操作が出来ないという問題は起きないということです。
動的型付け言語では、型エラーの可能性を、テストを充実させることで排除するアプローチを取ります。
ただ、テスト漏れの可能性が常にあることを考えれば、静的片付け言語に比べて非力であることは否めません。
特に長期間のメンテナンスを考えた場合、静的型付け言語が有利だと思います。

C++ において静的に型が決まらない例外もあります。
ひとつは virtual メンバ関数を使って多態しているオブジェクトを格納するポインタに対する `dynamic_cast` です。
これに関しては静的に型が決定せず、動的に型が解決されるため、プログラムのロジックが間違っていれば、`dynamic_cast` に失敗し、セグメンテーションフォールトをするなど不正な動作となります。
もうひとつは、`reinterpret_cast` や C 言語のキャストなどの強制的なキャストです。
強制的なキャストは、コードを書いた人の責任で「無理矢理」そのオブジェクトを別の型であると見なす行為ですから、
その対象が互換性があることを保証する責任はコンパイラではなくコードを書いた人が負います。
もちろん不具合があれば期待通りに動かなかったり、不正な挙動をしてデータが壊れたりします。
キャストは型エラーの可能性を生み出す行為なので、
コンパイラが型で守ってくれる世界から逸脱する行為であることに十分注意してください。


### コメント

コメントは読み手の理解を助けます。
つまりメンテナンス性に寄与します。
コードを読めば分かることは書かないようにしましょう。
主に何故そうしたのか、コードを読んだだけでは分かりにくいと思われるときに書きます。
複数のやり方があり得たがなぜそれを選んだのか、そのコードの実行結果は何をもたらすのか、生成物は何に使われるのか、などです。
What ではなく Why を書くようにしましょうと良く言われます。
また、変数や関数の名前が長すぎるのも問題なので、名前は短めにしておいて、意味を補う目的でもコメントを使います。


### 部品化

同じ処理が複数の箇所に存在しているとメンテナンス性に悪影響を与えます。
**DRY** (*Don't Repeat Yourself*) 原則と呼ばれますが、コードだけでなくドキュメントやコメントも含めて情報の重複を避けることが求められています。
ある箇所を修正したら、同じ情報が書いてある別の箇所も修正する必要がある場合、DRY 原則に違反しているといえます。
部品化しましょう。
部品化とは、複数の変数や引数をひとつのクラスにまとめたり、複数行のコードを関数として独立させたりすることです。
コード量が単純に減ることで、潜在的にはコードを読む労力が減りますし、重複がないということは、修正の労力も減りますし、修正し忘れを防止できます。


制御構造がコードに埋もれるとメンテナンス性に悪影響を与えます。
`if` や `for` などの制御ブロック内に、大量のコードがあったり、その場での入れ子構造が何重にもなっている状態は、良くありません。
コードを読む場合、制御構造は今どこを読むべきかを判断するための重要な情報なので、埋もれると読みづらくなります。
また、制御構造を変更・修正する場合、制御ブロック内に大量のコードがあると、これらの一部または全部を移動するテキスト編集が必要となり、その際にミスが起きやすくなります。
このような処理は、たとえ 1 回しか呼ばれないとしても、部品化を検討しましょう。


たった 1 行の処理も部品化すべきでしょうか？ 場合によっては「すべき」といえます。
例えば、何をやっているか一見分からない処理が 1 行で書かれていて、そのような処理が複数箇所で行われていて、その処理を良い名前で表現できるときなどです。
1 箇所でしか使わないなら、コメントにその名前を書いておくのでも良いでしょう。
インライン展開されれば関数呼び出しのオーバーヘッドはありませんので、余程大量に呼ばれる処理でなければ気にせず関数として切り出し、気になるのであれば明示的なインライン化をコンパイラにお願いしましょう。


度重なる修正でクラスのメンバ変数が増えすぎたとき、関数内で定義されるローカル変数が増えすぎたとき、ひとつの関数に渡す引数が多すぎるときも、部品化を検討しましょう。
複数のメンバ変数をまとめて別のクラスに分離したり、複数のローカル変数や引数をまとめてクラスとして定義したり、関数内の一部の処理を別の関数として分離したり、です。
具体的にどのくらいの数や量なら多すぎるのかについては言いづらいですが、
あなたがコードレビューする立場であれば、多いな、と思ったら迷わずそれを指摘し、
部品化するメリットやデメリットについて議論するようにしましょう。


一方、部品化のやりすぎも禁物です。
少しコードが減るからといって、共通の部品にしなければ不要だった `if` 文をむやみに発生させるのはよくありません。
そのような `if` 文が増えてきたらそれは部品をふたつもしくはそれ以上の数に分離させるべき合図です。
コピーして、別の名前をつけ、不要になった `if` 文を削除します。
あくまで部品化は、メンテナンス性向上ための手段のひとつであり、部品化を目的化してはいけません。


###  疎結合

関数やクラスなどの部品同士が疎結合になっているかどうかも、メンテナンス性に影響します。
例えば、あるクラスだけを見たとき、公開しているメンバ変数や関数インターフェースが少なく、それを呼ぶ箇所が少なくできるならその方がより疎結合だといえるでしょう。
同様に、関数の引数が少ない方が疎結合でしょう。
より疎結合であれば、ある処理を追うときに読まなければならないコード量が減ります。


疎結合であることを、より具体的に表現するとしたら、グラフ構造を使うのが適切かと思います。
モデル化の方法はいくつか考えられますが、例えば関数やクラスがノードで、それらを引数で渡したり関数内で呼んだりするのがノード間のエッジに相当すると考えてみましょう。
グラフ構造が疎結合であるとは、ノードあたりのエッジ本数が少ないことを意味します。
異なる機能を実現するコード同士で比較できるものかは分かりませんが、少なくとも同じ機能を実現するためのコード同士、リファクタリング前と後を比較するときに、このようなグラフ構造を考えて、エッジ本数が少ない方がよりメンテナンスしやすいコードであるとは言えると思います。
ソフトウェア工学の分野では、このような構造か、別の構造を用いた、より良い指標があるかも知れませんので、興味のある方は調べてみて下さい。私はあまり詳しくありません。


部品化を行うと、上で考えたグラフ構造の上では、ノード数が増え、エッジ数も増えると思います。
大きな関数やクラスを部品とみれば、それらの依存関係は疎結合だったとしても、より細かい単位での部品をノードだと考えれば、依存関係がクラス内や関数内に存在し、それらが実際は密結合であるにも関わらず、その事実が隠れてしまっているだけだったりします。
通常は、部品化を優先させ、それが十分満たされたと判断してから、クラスや関数単位での疎結合化を考えるのが良いと思います。


### const

const を適切に使うことがメンテナンス性に大きな貢献をすることは既に説明しました。
その理由は、繰り返しになりますが、const であるべきものが const になっていると、
コードを読むとき、修正をするときに、const を見て「これは変更されない」と判断でき、
読む量が減るからです。

グラフ構造を使ってソフトウェアは疎結合の方が良いと説明しましたが、
non-const と const のアクセスでエッジの重み(もしくは線の太さ)を変えることとし、
non-const よりも const の方が重みは小さい(線は細い)こととすれば、
const を使った方がメンテナンス性が良いことを表現できるかと思います。
const を適切に使うと、ソフトウェアがより疎結合になる、そんなイメージを持って下さい。


### テスト

メンテナンス性の担保にテストは欠かせません。
特に、定期的に、もしくはコードの修正が反映された契機にテストを実行してくれる CI (Continuous Integration) ツールの利用は、
我々が安心してコードを修正するのに必須といっても過言ではないです。
コード修正によるリグレッションは長期間メンテナンスするコードでは特に気をつけなければなりません。
リグレッションとは、コードの修正が、かえって不具合を埋めこんでしまうことを指します。
少なくとも、テストを書いてそれを CI ツールで動かすようにしていれば、テストが通らないことでリグレッションの発生をすぐに検知でき、
修正するなどの対応ができます。
テストがカバーしていない領域で発生する不具合は防げませんが、典型的なユースケースは大抵テストがカバーしていますので、
うっかりミスにすぐ気付けるだけでも有り難いものです。

様々なテストフレームワークがありますが、何を使うとしても CI ツールでリグレッションテストを実行することを意識しておけば良いと思います。
ごくごく単純なユニットテスト用途で十分なものとして、[cybozulib](https://github.com/herumi/cybozulib) の `test.hpp` をオススメしておきます。


```c++
#include "cybozu/test.hpp"

CYBOZU_TEST_AUTO(test_a)
{
    int i = 0; j = 0;
    CYBOZU_TEST_EQUAL(i, j);
    CYBOZU_TEST_ASSERT(i == 0);
}
```
このように書いてコンパイルすると、テスト成功時は 0 、失敗時はそれ以外が返る実行ファイルが出来ます。

環境の整備や初期化などが必要なテストは、もっと複雑な機構が欲しくなるかも知れませんが、必要に応じてスクリプトを作ったりして対応すれば良いと思います。
実行したらテスト成功か失敗かを判別できる出力をし、自動化しやすい形でプログラムとして作っておくのが重要です。
