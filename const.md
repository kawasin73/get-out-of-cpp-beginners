## const


[const や volatile](https://en.cppreference.com/w/cpp/language/cv) 修飾子は cv-qualifiers と呼ばれます。
volatile は一部の特別な用途を除いてほぼ使わないので、ここでは気にしないことにして、
const の有り難さについて説明していきます。
一番伝えたいメッセージは「**const を制するものは C++ を制す**」です。
const をうまく使うことで、コードの読み易さ、メンテナンスのしやすさは格段に上がると思ってください。
const というのは我々がプログラム内の変数や関数に与える制約であり、
const を使えばコンパイラがその制約を満たしているかどうかをチェックしてくれます。
仮に const がなかったとしても C++ で作るプログラムに出来ることは変わりません。
しかし、const を適切に使えば我々は const に大いに助けられていることを実感するでしょう。
C 言語においても const は有り難いものでした。
C++ にはメンバ関数によって振る舞いを自分で定義できるクラスがあり、
これが const の仕組みを使うことでさらに強力に我々をサポートしてくれます。


### const の意味

const は constant の略で、不変の、という意味を持ちます。
const を使うことで、変数やオブジェクトに「変えられないよ」という制約を与えることになります。
別の言い方をすると、read-only という性質を持つわけです。
人間というのは忘れっぽい生き物なので、昨日の時点で変えないと決めたものを、今日になると変えようとするコードを平気で書いてしまうものです。
コンパイラが const の記述を見て、コラコラ、それは変えられないよ！と怒ってくれるので、我々は、ああ、そこには変えられないという制約を入れたんだった、と我に返ることができ、間違ったまま開発が進むことを避けられます。
重要なことは、プログラムにおいて、データの変更よりも参照する(参照型変数と混同するのでややこしいですが、ここでは変更を伴わない read-only アクセスのことです)ことの方が多いという事実です。
const によりオブジェクトの変更が発生するコードを限定しておくことで、コードを読むときや変更するときに考えなければならないことがぐっと減ります。


### const 変数

変数の種類は 3 つあるのでした。
値型変数、ポインタ、参照。
これら全ての宣言に const をつけられます。
ひとつづつ説明していきます。


値型変数を const として扱うときは、変数宣言時に型の前に `const` をつけます。
`int` のような算術型であれば `const int i = 1;` のように、代入演算子で初期化し、
クラス型 `A` であれば、`const A a(arg1, arg2, ...);` もしくはその他の手段でコンストラクタを呼んで初期化します。
const 変数 `i` や `a` は変更できません。
変更できないとは、以下の意味を持ちます:

- メンバ変数へのアクセスは non-const のものも含めて全て const 扱いになります。変更できません。
- const メンバ関数は呼べますが、non-const メンバ関数は呼べません。

値型変数への再代入操作は、コピー代入演算子かムーヴ代入演算子が呼ばれたことになります。
算術型などの基本型の再代入は non-const メンバ関数だと見做して良いです。
すなわち const 値型変数への再代入はできません。
変数宣言時の初期化以外の手段で値を設定変更できません。

```c++
struct A
{
    int i;
    A() : i(0) {}
    A(int i0) : i(i0) {}
    void const_func() const {}
    void nonconst_func() {}
};

int main()
{
    const int i = 10;
    // i = 20;  // コピー代入演算子は non-const なので呼べない
    int j = i;  // もちろん読むことはできる

    const A a(10);
    // a.i = 20;  // a は const なので、メンバ変数は const 扱いとなり変更できない
    j = a.i; // もちろん読むことはできる
    a.const_func();
    // a.nonconst_func()  // a は const なので non-const メンバ関数は呼べない
    // a = A(30);  // コピー or ムーヴ代入演算子は non-const なので呼べない
}
```

ポインタの宣言では、const を付ける場所によって 2 通りの意味があります。
`const A* const a;` と書いたとき、ひとつ目の const は、以下の意味を持ちます:

- (ポインタが指すオブジェクトの) メンバ変数へのアクセスは non-const のものも全部 const 扱いになり、変更できません。
- (ポインタが指すオブジェクトの) const メンバ関数は呼べますが、non-const メンバ関数は呼べません。

ふたつ目の const は、以下の意味を持ちます:

- ポインタ変数への再代入はできません。宣言時の初期化以外で値(アドレス)を設定できません。

ふたつ目の const を使うことはあまりありません。
ポインタを使うときは、ポインタが格納しているアドレスを変更するよりも、
ポインタが指しているオブジェクトそのものを変更できるかどうかに注目することが多いからです。

```c++
int main()
{
    A a(10);

    const A* a0 = &a;
    // a0->i = 20;  // a0 が指すオブジェクトの non-const メンバは呼べない
    int j = a0->i;  // 読むことはできる
    a0->const_func();
    // a0->nonconst_func();  // 呼べない
    // *a0 = A(30);  // 呼べない
    a0 = nullptr;  // ポインタの再代入はできる

    A* const a1 = &a;
    a1->i = 20;
    a1->nonconst_func();
    *a0 = A(30);
    // a1 = nullptr;  // ポインタの再代入ができない

    const A* const a2 = &a;
    // a2->i = 20;
    // a2->nonconst_func();
    // *a2 = A(30);
    // a2 = nullptr;
}
```

const 参照変数の宣言は `const A& a;` のように書きます。ポインタのようなふたつめの `const` はありません。
`=` 演算子によって const 参照変数に再代入する操作は、それが指すオブジェクトのコピー代入演算子かムーヴ代入演算子を呼んだことになり、
それらの演算子は const ではないので、もちろん許されません。
つまり、const 参照が指すオブジェクトへの再代入は(少なくとも const 参照経由では)出来ません。
参照変数の宣言時からそれが指しているオブジェクトの中身を設定変更できません。

```c++
int main()
{
    A a(10);

    const int& i = a.i;
    // i = 20;  // コピー代入演算子は non-const なので呼べない
    int j = i;  // もちろん読むことはできる

    const A& a0 = a;
    // a.i = 20;  // メンバ変数は const 扱いとなり変更できない
    j = a.i; // もちろん読むことはできる
    a.const_func();
    // a.nonconst_func()  // non-const メンバ関数は呼べない
    // a0 = A(30);  // コピー or ムーヴ代入演算子は non-const なので呼べない
}
```

宣言した変数が const だった場合、周辺コードを修正しようとしたときに、我々はその変数は
「変更されない」ものとして扱って良いわけです。
変更すべきでないと思って const で変数を宣言したけれど、後日、そのことを忘れて誤って変更しようとしたとき、コンパイラが怒ってくれますので間違いに気付きやすいのです。
コードを読む人も、主にオブジェクトがどう変更されるかに注目して処理の流れを追うことが多く、変数が const 宣言してあれば、初期化時以外は注意の対象から外して良いと分かるので、負担が減ります。


### 仮引数の const

関数の仮引数に `const A a` と書くのは好みの問題ですが、どうせ値渡しでコピーされているので、呼び出し元には影響がありませんし、関数シグネチャも値渡しの場合は const のありなしで区別されません。
関数内ではもちろん const 変数として扱われますが、インターフェースとしては違いがありませんので、私は値渡しの場合は const を付けないことにしています。
もしどうしても const にしたかったら、`A a` と仮引数に書いておいて、関数の最初で `const A& a0 = a;` とでも宣言して `a0` を使えばある程度目的は達成されるかも知れませんが、これは面倒くさい割にメリットが少ないかなと私は感じます。

関数の仮引数に `const A* p` と書いたとき、関数内では `p` が指すオブジェクトを変更できないことを意味します。
呼び出し側は関数呼び出し後も `p` が指すオブジェクトが変更されていないことをほぼ確信できます。
これがメンテナンス性にとても影響します。
自分が読んでいる、または修正しているコードにおいて、関数呼び出しがあったとき、ポインタ渡しまたは参照渡しした変数の中身が関数呼び出しの前後で変わるかも知れないと分かれば、それがどう変わるのかを知る必要があります。
実際は中身を変えていないとしても、引数に const がついていなければ、変えていないかどうかコードを読んで確認しないといけません。
const がついていれば、その中身に立ち入ることなく安心して変えられていないことを信じられます。
実は、`const_cast` などで無理矢理キャストすればオブジェクトを変更できますが、そんなことをするコードはお行儀が悪く、忌むべき存在です。
const を適切に使った場合、`A* p` を引数として持っている関数は、 `p` が指すオブジェクトを変更することが想定され(条件分岐の結果変更しないケースはあるでしょうけれど)、`const A* p` を引数として持っている関数は、`p` の指すオブジェクトを変更しないことが分かります。
ポインタ仮引数に関して、const の有無は異なるシグネチャとして区別されますので、`void f(const A* p)` 版と `void f(A* p)` 版は別の実体としてオーバーロード定義できます。


参照についてはポインタと同様です。


### 返り値の const

関数の返り値に `const A` と書けますが、手元でコンパイラを動かしてみたら、warning が出ました。
返り値の場合は、`const A f()` と `A f()` のシグネチャの区別がされないだけでなく、挙動の違いもありません。
つまり値型を返す場合は `const` を付ける意味がまったくありません。


関数の返り値に `const A*` と書くとき(`A*` も同様ではありますが)、
返されるものは関数内ローカル変数へのポインタではないことは確認してください。
寿命が尽きているオブジェクトを指しているポインタ/参照を dereference するのは明らかなバグです。
引数もしくはグローバル変数/メンバ変数に含まれるオブジェクト、それらが指しているヒープオブジェクトなどが指されているはずです。
この const は、返った先でそれが指しているオブジェクトが変更されないことを約束します。
`A*` を返してしまったらオブジェクトが変更されても文句はいえません。
変更されたくない場合に const ポインタを返すことはよくあります。
コードの影響範囲という意味において、`const A*` を返すか `A*` を返すかは明らかに後者の方が影響範囲は大きいと見るべきです。
ただ、グローバル関数の返り値がポインタであるとき、const をつける意味は限られます。
引数が const で変更する権限がないから、返り値にも const をつけているときくらいでしょうか。
グローバル変数から辿れるオブジェクトを指している場合は、大体のケースで誰でも変更できますので、関数の返り値が const ポインタである意味があまりありません。
const ポインタを返す方法が多用されるのは、オブジェクトのメンバ関数で、メンバ変数へのポインタを返すときです。
オブジェクト外の人に読まれるのは構わないけれど、変更されるのは拒否したいときに役に立ちます。
関数呼び出し側からは直接アクセスできないファイルローカル変数へのポインタを返す場合は、
グローバル関数の返り値でも const ポインタにする意味があるでしょう。


参照についてはポインタと同様です。


### const メンバ変数

const メンバ変数とは、クラスのメンバ変数宣言において `const` を指定したものです。
こうすると、コンストラクタの初期化子で初期化した後はオブジェクトの外はおろかメンバ関数内でも一切変更できなくなります。
例えば、immutable objects (不変オブジェクト) を作る方法として、メンバ変数を全部 const で宣言してしまうという方法があります。
こうすると、オブジェクト自身を const 変数として扱わなくてもメンバ変数が全て const なのだから一切変更できません。

```c++
struct A
{
    const int i;
    const int j;
    A(int i0, int j0) : i(i0), j(j0) {}
};

int main()
{
    A a(10, 20);  // const 変数ではないのに変更できない
    // a.i = 30;  // const メンバ変数なので変更できない
    // a.j = 40;
}
```

逆に、デフォルトコンストラクタで何もしないことにして(例えば、`struct A { A() = default; };` ) 、後でメンバ変数を設定しようと思っていたら、メンバ変数は const にできません。

```c++
struct A
{
    int i;
    int j;
}

int main()
{
    A a;
    a.i = 10;
    a.j = 20;
}
```

この 2 つの例は極端なものですが、具体的にどうするかは設計次第だと思います。
私は const 変数がたくさんあるクラスはあまり作りたくありません。
コンストラクタに引数をたくさん渡さないといけないのも初期化子指定をたくさん書くのも嫌だからです。
そのような場合は const にしたい変数をまとめたクラスを別途作って、そのオブジェクトもしくは参照を
const メンバ変数として持つのが良いかなと思います。
また、私は immutable object を作りたいと思ったことは記憶の限りではないですが、
絶対に変更したくない、されたくない、という強い動機が発生すれば今後作ることがあるかも知れません。


### const メンバ関数

const メンバ関数はとても重要です。
オブジェクトが const であるとき、すなわち `const T` 型であるか、`const T&` または `const T*` で指されているとき、その変数経由では、const メンバ関数しか呼び出しできません。
つまり、クラスを定義するときは const オブジェクトの振る舞いを定義するために const メンバ関数と non-const メンバ関数を分けます。
const メンバ関数内では、non-const メンバ変数であっても const 扱いになり、変更できません。
ですから、const メンバ関数はオブジェクトの状態を何も変更できないことになります。
これは const オブジェクトとして期待される振る舞いですね。

例外として、実際は変更されるけれど、オブジェクトが変更されたと見做したくない場合、
例えば mutex オブジェクトなどについては、`mutable` キーワードをつけてメンバ変数を宣言しておくことで、
const メンバ関数の中で変更が可能になります。
これはあくまで例外的な操作のためのものなので、多用は禁物です。
人から聞いた話ですが、過去に `mutable` を使ったクラスを設計したところ、
後のユーザに const メンバ関数はスレッドセーフだと思われたが、
mutable 変数を操作している const メンバ関数は状態を変更しているので、
実はスレッドセーフではなく、困ったそうです。

const メンバ関数は non-const メンバ関数とオーバーロードできますので、必要に応じて定義してください。
以下のような例が挙げられます。

```c++
struct A
{
    std::string s;
    const char& get(size_t i) const { return s[i]; }
    char& get(size_t i) { return s[i]; }
};
```
const 版では const 参照や const ポインタを返すことによって、const オブジェクトとしての振る舞いを保つことができます。
このようなオーバーロードは STL コンテナでよく使われています。


### const 教のお約束

C/C++  の const (もしくは他言語における同様の機能) を適切に使うことにより、コードの読み書きにおいて多大な恩恵を受けられると信じる宗教のことを const 教というらしいです。
その教義は以下の 2 つだと思います:

1. 変更されないのに、const をつけずに放置してはいけない。
2. const がついているのに、キャストなどを使って無理矢理中身を変更してしまってはいけない。

これらは const の恩恵を受けるための「お約束」です。
お約束を良く考えずに破ってしまうと、const で信頼されている世界が崩壊してしまい、メンテナンス性を著しく下げてしまうでしょう。
また、お約束が守られていないコードを書いてしまったら、レビューで怒られる可能性が高いです。

とはいえ、何事にも例外はあります。
ひとつ目の例外は、実際にはオブジェクトの一部を変更するが、コードの意味としてオブジェクトが変更されたとはみなすべきではないとき、
キャストや `mutable` を使って変更することは多少は許容されるでしょう。
ただし、何故そうするかをコメント等で書いておくのが親切です。
コードを読む人に言い訳しておく必要があると思います。
そして、const であることに矛盾が生じない設計を心がける必要があると思います。
ふたつ目の例外は、高々数行のスコープしかない変数について、実質的に const であることがすぐに分かるものでも
const を付けるべきかどうかという問いに対して、私は別に見てすぐに分かるならそこまで気にする必要ないじゃないか、と思います。
迷ったときは可読性やメンテナンス性という目的に合うかどうかを考えれば良いと思います。
より上位の目的はメンテナンス性であり、const に固執しすぎる必要はありません。

const 教を無理に信じなくても、const が適切に使われるコードを読んだりメンテナンスする機会があれば、
その有り難みを実感、納得でき、const をうまく使えるようになるでしょう。
私は信者なのかって？原理主義というわけでもありませんが、初心者向けの本書に const のことを力説するくらいには信者だと思います :)
